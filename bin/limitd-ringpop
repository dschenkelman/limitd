#!/usr/bin/env node

var TChannel = require('tchannel');
var program = require('commander');
var path = require('path');
var fs = require('fs');
var yaml = require('js-yaml');
var _ = require('lodash');
var LimitdServer = require('../server');
var Ringpop = require('ringpop');
var dns = require('dns');
var async = require('async');

program.version(require('../package').version)
  .option('-d --db <file>', 'Path to the database.')
  .option('-p --port [9231]', 'Port to bind [9231].', '9231')
  .option('-r --ringpop-port [9696]', 'Port to bind [9696].', '9696')
  .option('-h --hostname [0.0.0.0]', 'Hostname to bind [0.0.0.0].', '0.0.0.0')
  .option('-c --config-file <file>', 'Configuration file.')
  .option('--avro', 'Use the avro protocol.')
  .option('--profile')
  .parse(process.argv);

var config = _.pick(program, ['db', 'port', 'ringpopPort', 'hostname', 'configFile']);

console.log('config init', config);

if (program.avro) {
  config.protocol = 'avro';
}

if (config.configFile) {
  try {
    var config_file = path.resolve(process.cwd(), config.configFile);
    var doc = yaml.load(fs.readFileSync(config_file, 'utf8'));
    _.extend(config, doc);
  } catch (e) {
    console.error('Error loading configuration\n', e.stack);
    setTimeout(function () {
      process.exit(1);
    }, 500);
  }
}

var hostPorts = {
    'limitd': 9696,
    'limitd2': 9696
};

var hosts = Object.keys(hostPorts);

console.log('config', config);

console.log('fetching dns names for bootstrap nodes');
async.map(hosts, dns.resolve4, function(err, results){
    if (err) { return console.error(err); }

    console.log('names resolved', results);
    
    var nodes = _.zip(hosts, results.map(function(addresses){
        return addresses[0];
    })).reduce(function(nodes, element){
        var hostName = element[0];
        var port = hostPorts[hostName];
        nodes[hostName] = { ip: element[1], port: port };

        return nodes;
    }, {});

    var bootstrapNodes = { limitd: nodes['limitd'] };

    var bootstrapAddresses = _.values(bootstrapNodes).map(function(host){
        return host.ip + ':' + host.port;
    });

    var thisNode = nodes[config.hostname];

    console.log('bootstrapNodes', bootstrapNodes);

    console.log('thisNode', thisNode);

    var tchannel = new TChannel();

    var ringpop = new Ringpop({
        app: 'limitd',
        hostPort: thisNode.ip + ':' + thisNode.port,
        channel:  tchannel.makeSubChannel({
            serviceName: 'ringpop',
            trace: false
        }),
        logger: createLogger('limitd-ringpop')
    });

    ringpop.appChannel = tchannel.makeSubChannel({
        serviceName: 'limitd'
    });

    ringpop.setupChannel();

    tchannel.listen(thisNode.port, 
        thisNode.ip, 
        function onListening() {
            console.log('listening', bootstrapAddresses);
            console.log('bootstrapping ringpop');
            ringpop.bootstrap(bootstrapAddresses, onBootstrap);
        });

    function onBootstrap(err) {
        console.log('on bootstrap');
        if (err) {
            // Fatal error
            return console.error(err);
        }

        console.log('running ringpop like a boss');

        // Start listening for application traffic
        var server = new LimitdServer(config);

        server.start();

        if (program.profile) {
            var profiler = require('v8-profiler');
            profiler.startProfiling('1', true);
        }
    }
});

function finish () {
  if (program.profile) {
    var profile1 = profiler.stopProfiling();
    return profile1.export(function(error, result) {
      fs.writeFileSync(process.cwd() + '/profile.cpuprofile', result);
      profile1.delete();
      process.exit(0);
    });
  }
  server.stop(function () {
    process.exit(0);
  });
  setTimeout(function () {
    process.exit(0);
  });
}

function createLogger(name) {
    return {
        trace: function noop() {},
        debug: enrich('debug', 'log'),
        info: enrich('info', 'log'),
        warn: enrich('warn', 'error'),
        error: enrich('error', 'error')
    };f

    function enrich(level, method) {
        return function log() {
            var args = [].slice.call(arguments);
            args[0] = name + ' ' + level + ' ' + args[0];
            console[method].apply(console, args);
        };
    }
}

process
  .on('SIGTERM', finish)
  .on('SIGINT', finish);